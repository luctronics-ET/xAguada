Aguada - bot√£o principal
pre loader √≠cone aguada

pag supervis√≥rio √≠cone usado em painel de controle)
consumo do dia atual do castelo de consumo (T) (somat√≥rio dos consumos parciais(diferen√ßa de volume entre leituras do dia)
se volume atual >= volume anterior, consumo parcial == 0;
se volume atual < volume anterior, consumo parcial = vol anterior - vol atual;
tendencia = compara√ß√µes com a media de consumo do quarto de hora - alto, normal, baixo, vazamento (consumo muito alto)
consumo di√°rio += consumo parcial

titulo aba navegador: CMASM - Aguada

sub paginas:

pagina CMASM Aguada
gr√°fico linha  do volume castelo consumo, eixos: 0- vol total / percentual, per√≠odo de 24 h ate agora) e do consumo di√°rio no mesmo gr√°fico   ocupar toda largura do contente desde side bar ate canto direito

data table resumo
consumo di√°rio T √≠cone tendencia
volume atual do castelo consumo  % T
volume atual castelo inc√™ndio % T
volume atual cisternas IF % T

data table resumo controles de qualidade

data table status reservatorios

tabelas bombas 
tabela v√°lvulas (bot√µes trigger com feed back) usu√°rio pode alterar manualmente.

tabela 
cada quarto( 00-04h, 04h-08h, 08h-12h, 12h-16h, 16-20h, 20-24h)
consumo di√°rio T
volume 

alertas ativos


pagina aguada | Registros: - ler dados detalhados
gr√°fico
tabelas com as leituras e dados


pagina aguada | manuten√ß√£o - verificar integridade e estado dos equipamentos do sistema
datatable sobre status sensores, bombas, v√°lvulas

datatable manuten√ß√£o sensores, bombas, v√°lvulas

datatable ultimas verifica√ß√µes/manuten√ß√µes




ESP 01
Castelo de Consumo
reservat√≥rio de 80 ton de agua para consumo;
v√°lvula de entrada: recebe agua das cisternas IE 01 e 02,
v√°lvula de sa√≠da AZ: envia agua para Area azul (AZ); 
v√°lvula de sa√≠da AV: envia agua para Area vermelha (AV);

ESP 02
Castelo de Incendio
reservat√≥rio de 80 ton de agua para rede de combate a incendio;
v√°lvula de entrada: recebe agua das cisternas IE 01 e 02,
v√°lvula de sa√≠da AZ: envia agua para rede de inc√™ndio (rede CAV AZ); 

ESP 03
Cisterna IE
Cisterna IE 01 - reservat√≥rio de 250 ton de agua;
Cisterna IE 02 - reservat√≥rio de 250 ton de agua;
v√°lvula de sa√≠da CON: envia agua para Castelo de Consumo
v√°lvula de sa√≠da CAV: envia agua para Castelo de Incendio
v√°lvula de entrada 01: cisterna IE 01 recebe agua das cisternas IF
v√°lvula de entrada 02: cisterna IE 02 recebe agua das cisternas IF




### Topologia inicial detalhada

#### ESP 01 ‚Äî Castelo de Consumo
- **Reservat√≥rio**: 80 t (‚âà 80 m¬≥), com medi√ß√£o de n√≠vel por ultrassom.
- **V√°lvulas**: entrada (das cisternas IE01/IE02), sa√≠da AZ (√Årea Azul), sa√≠da AV (√Årea Vermelha).
- **Bombas/Press√£o**: opcional leitura de press√£o na rede de consumo para diagn√≥stico.
- **Sugest√µes de I/O**:  
  - **Ultrassom** JSN-SR04T (√† prova d‚Äô√°gua) em 5 V; usar divisor no pino ECHO para 3,3 V.  
  - **Entradas digitais** para estados de v√°lvulas (contato seco) com optoacoplador e debounce.  
  - **Amostragem**: leitura a cada 10 s; publicar a cada 30 s ou sob varia√ß√£o relevante.

#### ESP 02 ‚Äî Castelo de Inc√™ndio
- **Reservat√≥rio**: 80 t (‚âà 80 m¬≥), medi√ß√£o de n√≠vel por ultrassom.
- **V√°lvulas**: entrada (IE01/IE02), sa√≠da AZ (rede CAV AZ).
- **Bombas/Press√£o**: recomend√°vel press√£o na rede de inc√™ndio para detec√ß√£o de quedas.
- **I/O e amostragem**: iguais ao ESP 01; avaliar taxa maior (5 s) para alarmes cr√≠ticos.

#### ESP 03 ‚Äî Cisternas IE
- **Reservat√≥rios**: IE01 e IE02, 250 t cada (‚âà 250 m¬≥ cada), 2 medi√ß√µes de n√≠vel por ultrassom.
- **V√°lvulas**: sa√≠da CON (para castelo de consumo), sa√≠da CAV (para castelo de inc√™ndio), entrada 01 (de IF para IE01), entrada 02 (de IF para IE02).
- **I/O**: duas medi√ß√µes de n√≠vel independentes + entradas digitais para 4 v√°lvulas.
- **Amostragem**: n√≠vel a cada 15 s; publicar a cada 60 s ou sob varia√ß√£o.

> Observa√ß√£o: 1 t de √°gua ‚âà 1 m¬≥. Para converter n√≠vel em volume, definimos √°rea de se√ß√£o transversal ou uma tabela de calibra√ß√£o espec√≠fica do reservat√≥rio.

---

### Nomenclatura, t√≥picos MQTT e payloads

#### Identidades e t√≥picos
- **Site**: xaguada/site-a (ajuste conforme necess√°rio).
- **N√≥s**:  
  - ESP01 ‚Üí xaguada/site-a/consumo  
  - ESP02 ‚Üí xaguada/site-a/incendio  
  - ESP03 ‚Üí xaguada/site-a/cisternas  
  - Gateway ‚Üí xaguada/site-a/gateway

- **T√≥picos**:
  - **Telemetria**: xaguada/site-a/<no>/telemetry
  - **Eventos/Alarmes**: xaguada/site-a/<no>/events
  - **Comandos**: xaguada/site-a/<no>/cmd
  - **Estado do n√≥**: xaguada/site-a/<no>/status

> QoS: use QoS 1 para telemetria e eventos; reten√ß√£o apenas para ‚Äústatus‚Äù e √∫ltima configura√ß√£o.

#### Payloads de telemetria (exemplos)

- **ESP01 (consumo)**:
```json
{
  "device_id": "consumo",
  "ts": "2025-08-31T22:10:00Z",
  "nivel_cm": 245,
  "volume_m3": 62.3,
  "pressao_bar": 3.1,
  "valvulas": { "entrada": 1, "saida_az": 0, "saida_av": 1 },
  "bombas": {},
  "rssi": -65,
  "fw": "1.0.0"
}
```

- **ESP02 (inc√™ndio)**:
```json
{
  "device_id": "incendio",
  "ts": "2025-08-31T22:10:02Z",
  "nivel_cm": 240,
  "volume_m3": 60.9,
  "pressao_bar": 7.5,
  "valvulas": { "entrada": 1, "saida_az": 1 },
  "rssi": -63,
  "fw": "1.0.0"
}
```

- **ESP03 (cisternas)**:
```json
{
  "device_id": "cisternas",
  "ts": "2025-08-31T22:10:05Z",
  "nivel_cm": { "ie01": 290, "ie02": 275 },
  "volume_m3": { "ie01": 210.5, "ie02": 199.2 },
  "valvulas": { "saida_con": 1, "saida_cav": 0, "entrada_01": 1, "entrada_02": 0 },
  "rssi": -60,
  "fw": "1.0.0"
}
```

#### Comandos e configura√ß√£o
- **Comando**:
```json
{
  "target": "consumo",
  "cmd": "set_interval",
  "value": 10
}
```

- **Configura√ß√£o remota** (publicado pelo backend, consumido pelo n√≥):
```json
{
  "target": "cisternas",
  "cmd": "set_config",
  "value": {
    "report_sec": 60,
    "sensor": {
      "ie01": { "h_max_cm": 320, "area_m2": 0.78 },
      "ie02": { "h_max_cm": 320, "area_m2": 0.78 }
    },
    "alarms": { "low_pct": 20, "critical_pct": 10 }
  }
}
```

---

### C√°lculos e regras de alarme

#### C√°lculo de volume a partir do n√≠vel
- **Tanque prism√°tico**:
  
  \[
  V\,(m^3) = A\,(m^2) \cdot h\,(m)
  \]
  
- **Tanque cil√≠ndrico vertical**:
  
  \[
  V\,(m^3) = \pi r^2 \cdot h
  \]

- **Calibra√ß√£o por tabela**: se o tanque n√£o for regular, use pares \((h, V)\) e fa√ßa interpola√ß√£o linear.

#### Derivadas e taxas para diagn√≥stico
- **Taxa de varia√ß√£o do n√≠vel**:
  
  \[
  \Delta h/\Delta t = \frac{h_{t} - h_{t-\Delta t}}{\Delta t}
  \]
  
- **Estimativa de vaz√£o pela se√ß√£o** (aproxima√ß√£o):
  
  \[
  Q\,(m^3/s) \approx A \cdot \frac{\Delta h}{\Delta t}
  \]

#### Regras de alarme (iniciais)
- **Baixo n√≠vel**: volume < 20% ‚Üí Alerta; < 10% ‚Üí Cr√≠tico.
- **Queda r√°pida (poss√≠vel vazamento)**: \(|\Delta h/\Delta t| >\) limiar por N amostras consecutivas.
- **Contradi√ß√£o de v√°lvula**: v√°lvula ‚Äúaberta‚Äù sem varia√ß√£o de n√≠vel/press√£o em T segundos.
- **Falha de bomba**: comando ON sem aumento de press√£o em at√© 5 s.
- **Rede de inc√™ndio**: press√£o < limiar m√≠nimo por > 10 s mesmo com v√°lvulas fechadas ‚Üí investigar vazamento/ruptura.
- **Sensor an√¥malo**: leitura fora de faixa, eco do ultrassom perdido, jitter alto ‚Üí ‚Äúsensor_fault‚Äù.

> Filtragem: use uma m√©dia m√≥vel exponencial (EMA) nas leituras de n√≠vel e press√£o para reduzir falsos positivos antes da derivada.

---

### Firmware base do n√≥ e do gateway

#### Estrutura de configura√ß√£o no n√≥ (SPIFFS/LittleFS)
```json
{
  "device_id": "consumo",
  "report_sec": 30,
  "read_sec": 10,
  "ultrassom": { "trig": 4, "echo": 5, "h_sensor_cm": 1000, "h_zero_cm": 50, "avg": 5 },
  "digital": {
    "valvulas": { "entrada": 8, "saida_az": 9, "saida_av": 10 },
    "invert": true,
    "debounce_ms": 50
  },
  "area_m2": 0.78
}
```

#### N√≥ de sensor ‚Äî leitura e envio via painlessMesh (prot√≥tipo)
```cpp
#include <Arduino.h>
#include <painlessMesh.h>
#include <ArduinoJson.h>

#define MESH_PREFIX   "xaguada"
#define MESH_PASSWORD "x@gu@d@2025"
#define MESH_PORT     5555

painlessMesh mesh;

const int PIN_TRIG = 4, PIN_ECHO = 5;
const int PIN_V_IN = 8, PIN_V_AZ = 9, PIN_V_AV = 10;

unsigned long lastRead = 0, lastPublish = 0;
const uint32_t READ_MS = 10000;    // 10 s
const uint32_t PUB_MS  = 30000;    // 30 s

float emaLevel = NAN;
const float alpha = 0.3; // EMA

long readUltrasonicCM() {
  digitalWrite(PIN_TRIG, LOW); delayMicroseconds(2);
  digitalWrite(PIN_TRIG, HIGH); delayMicroseconds(10);
  digitalWrite(PIN_TRIG, LOW);
  long dur = pulseIn(PIN_ECHO, HIGH, 30000); // timeout 30 ms
  if (dur == 0) return -1;
  // Velocidade do som ~0.034 cm/us ida e volta
  long cm = (dur * 0.034) / 2;
  return cm;
}

void setup() {
  pinMode(PIN_TRIG, OUTPUT);
  pinMode(PIN_ECHO, INPUT);
  pinMode(PIN_V_IN, INPUT_PULLUP);
  pinMode(PIN_V_AZ, INPUT_PULLUP);
  pinMode(PIN_V_AV, INPUT_PULLUP);

  mesh.setDebugMsgTypes(ERROR | STARTUP);
  mesh.init(MESH_PREFIX, MESH_PASSWORD, MESH_PORT);
}

void loop() {
  mesh.update();
  unsigned long now = millis();

  static int v_in = 0, v_az = 0, v_av = 0;

  if (now - lastRead >= READ_MS) {
    lastRead = now;
    long dist_cm = readUltrasonicCM();
    if (dist_cm > 0) {
      float level_cm = dist_cm; // ajuste: converter dist√¢ncia ao espelho d'√°gua em n√≠vel √∫til
      emaLevel = isnan(emaLevel) ? level_cm : (alpha * level_cm + (1 - alpha) * emaLevel);
    }
    // Debounce simples por amostragem peri√≥dica
    v_in = digitalRead(PIN_V_IN) == LOW ? 1 : 0;
    v_az = digitalRead(PIN_V_AZ) == LOW ? 1 : 0;
    v_av = digitalRead(PIN_V_AV) == LOW ? 1 : 0;
  }

  if (now - lastPublish >= PUB_MS) {
    lastPublish = now;
    StaticJsonDocument<256> doc;
    doc["device_id"] = "consumo";
    doc["ts"] = (uint32_t) (millis()/1000);
    if (!isnan(emaLevel)) doc["nivel_cm"] = (int) round(emaLevel);
    JsonObject valvs = doc.createNestedObject("valvulas");
    valvs["entrada"] = v_in; valvs["saida_az"] = v_az; valvs["saida_av"] = v_av;

    char buf[256];
    size_t n = serializeJson(doc, buf);
    mesh.sendBroadcast(String(buf, n));
  }
}
```

#### Gateway root ‚Äî bridge mesh ‚Üí MQTT e comandos
```cpp
#include <Arduino.h>
#include <painlessMesh.h>
#include <WiFi.h>
#include <PubSubClient.h>

#define MESH_PREFIX   "xaguada"
#define MESH_PASSWORD "x@gu@d@2025"
#define MESH_PORT     5555

const char* STA_SSID = "LAN_LOCAL";
const char* STA_PASS = "SENHA";
const char* MQTT_HOST = "192.168.1.50";
const uint16_t MQTT_PORT = 1883;

painlessMesh mesh;
WiFiClient net;
PubSubClient mqtt(net);

void onMeshReceive(uint32_t from, String &msg) {
  if (!mqtt.connected()) { mqtt.connect("xaguada-gateway"); }
  mqtt.publish("xaguada/site-a/gateway/raw", msg.c_str());
  // Opcional: inspecionar payload e rotear para t√≥picos espec√≠ficos.
}

void onMqttMsg(char* topic, byte* payload, unsigned int len) {
  // Encaminhar comandos do MQTT para a malha
  String cmd = String((char*)payload, len);
  mesh.sendBroadcast(cmd);
}

void setup() {
  mesh.setDebugMsgTypes(ERROR | STARTUP);
  mesh.init(MESH_PREFIX, MESH_PASSWORD, MESH_PORT);
  mesh.onReceive(&onMeshReceive);

  WiFi.mode(WIFI_AP_STA);
  WiFi.begin(STA_SSID, STA_PASS);

  mqtt.setServer(MQTT_HOST, MQTT_PORT);
  mqtt.setCallback(onMqttMsg);
  // Assinar comandos gerais
  mqtt.connect("xaguada-gateway");
  mqtt.subscribe("xaguada/site-a/+/cmd");
}

void loop() {
  mesh.update();
  if (WiFi.status() == WL_CONNECTED) mqtt.loop();
}
```

> Produ√ß√£o: migrar para ESP-IDF/esp-mesh + esp-mqtt, adicionar buffer local, QoS 1, reconex√£o exponencial e OTA.

---

### Backend local offline (Docker) e fluxo

#### docker-compose para o stack local
```yaml
version: "3.8"
services:
  mosquitto:
    image: eclipse-mosquitto:2
    ports: ["1883:1883", "9001:9001"]
    volumes:
      - ./mosquitto.conf:/mosquitto/config/mosquitto.conf
    restart: unless-stopped

  nodered:
    image: nodered/node-red:latest
    ports: ["1880:1880"]
    volumes: ["./nodered:/data"]
    depends_on: ["mosquitto"]
    restart: unless-stopped

  influxdb:
    image: influxdb:2
    ports: ["8086:8086"]
    volumes: ["./influxdb:/var/lib/influxdb2"]
    restart: unless-stopped

  grafana:
    image: grafana/grafana:latest
    ports: ["3000:3000"]
    volumes: ["./grafana:/var/lib/grafana"]
    depends_on: ["influxdb"]
    restart: unless-stopped
```

- **Mosquitto**: habilite listener 1883 (MQTT) e opcional 9001 (WebSocket) para o dashboard.
- **Node-RED**:
  - **Fluxo**: MQTT-in (telemetry) ‚Üí valida JSON ‚Üí enriquecimento (volume, % n√≠vel) ‚Üí grava InfluxDB ‚Üí regras de alarme ‚Üí MQTT-out (events) + notifica√ß√£o (e-mail/Telegram).
  - **Config**: um fluxo por n√≥ (consumo, incendio, cisternas) e um fluxo comum de alarmes.
- **InfluxDB**:
  - **Buckets**: telemetry (retention 180 dias), events (retention 365 dias).
  - **Schema**:
    - measurement: telemetry; tags: site, node, sensor; fields: nivel_cm, volume_m3, pressao_bar, v_entrada, v_saida_az, v_saida_av.
    - measurement: events; tags: site, node, severity, type; fields: message.
- **Grafana**:
  - **Dash principal**: cards de n√≠vel/volume, press√£o, status de v√°lvulas, s√©rie temporal 24h/7d, lista de alarmes.
  - **Mapa/planta**: imagem da planta como background + ‚Äúgeomap/Canvas‚Äù com √≠cones e cores por status.

---

### Dashboard inicial e indicadores

- **Vis√£o geral**:
  - **Castelo Consumo**: n√≠vel (% e m¬≥), v√°lvulas (entrada/AZ/AV), tend√™ncia 24h, alarmes ativos.
  - **Castelo Inc√™ndio**: n√≠vel, press√£o, v√°lvula sa√≠da AZ, alarme de baixa press√£o.
  - **Cisternas IE**: n√≠veis (IE01/IE02), v√°lvulas sa√≠da CON/CAV e entradas 01/02, balan√ßo di√°rio.

- **KPIs**:
  - **Consumo di√°rio**: diferen√ßa de volume entre 00:00 e 23:59 por √°rea AZ/AV.
  
    \[
    \text{Consumo}_{dia} \approx \sum Q(t)\,\Delta t
    \]
    
  - **Horas de v√°lvula aberta**: integral do estado (1) ao longo do dia.
  - **Tempo em alarme**: soma de dura√ß√£o por tipo (vazamento, baixa press√£o).

- **Alertas cr√≠ticos (banner/sons)**:
  - Baixa press√£o na rede de inc√™ndio.
  - N√≠vel cr√≠tico em castelos/cisternas.
  - Queda r√°pida de n√≠vel com v√°lvulas fechadas.

---

### Pr√≥ximos passos imediatos

1. **Confirmar par√¢metros f√≠sicos**  
   - **Formato e dimens√µes** dos reservat√≥rios (para definir \(A\) ou tabela \((h,V)\)).  
   - **Altura √∫til** e posi√ß√£o do sensor (offset entre sensor e espelho d‚Äô√°gua).  
   - **Limiar de press√£o** m√≠nima da rede de inc√™ndio.

2. **Definir pinos e el√©trica**  
   - **Ultrassom JSN-SR04T** em 5 V, ECHO com divisor para 3,3 V.  
   - **Entradas digitais** com optoacoplador e pull-up; comunique se os contatos s√£o NA/NF.  
   - Se houver **press√£o anal√≥gica/4‚Äì20 mA**, especificar faixa e condicionamento (shunt 250 Œ© ‚Üí 1‚Äì5 V + prote√ß√£o).

3. **Subir o stack local**  
   - Criar arquivos de configura√ß√£o do Mosquitto (listener 1883, anonymous on/off conforme pol√≠tica).  
   - Configurar InfluxDB (org, bucket, token) e credenciais do Grafana.

4. **Flash do firmware prot√≥tipo**  
   - 1 gateway + 3 n√≥s com painlessMesh.  
   - Publicar telemetria nos t√≥picos definidos.  
   - Logar RSSI e hops para avaliar qualidade da malha.

5. **Construir o dashboard MVP**  
   - Painel √∫nico com tr√™s se√ß√µes (Consumo, Inc√™ndio, Cisternas).  
   - Tabela/stream de alarmes em tempo real.

Se voc√™ me passar as dimens√µes dos reservat√≥rios (di√¢metro/altura ou comprimento/altura/largura) e a altura de instala√ß√£o dos sensores, eu j√° te devolvo as f√≥rmulas ou uma tabela \((h,V)\) pronta para carregar nos n√≥s e no backend. Tamb√©m posso ajustar o firmware base para os tr√™s n√≥s com o mapeamento de pinos que voc√™ preferir.

castelo consumo
resevatorio.hsensor = 40;  // distancia do n√≠vel m√°ximo da agua ate o sensor, em cent√≠metros (int)
resevatorio..altura = 400; // altura do n√≠vel m√°ximo da agua do reservat√≥rio , em cent√≠metros (int)
resevatorio.diametro = 510 ;  // di√¢metro do reservat√≥rio , em cent√≠metros (int)

castelo aguada
resevatorio.hsensor = 20;  // distancia do n√≠vel m√°ximo da agua ate o sensor, em cent√≠metros (int)
resevatorio..altura = 400; // altura do n√≠vel m√°ximo da agua do reservat√≥rio , em cent√≠metros (int)
resevatorio.diametro = 510 ;  // di√¢metro do reservat√≥rio , em cent√≠metros (int)

Cistena IE 01
resevatorio.hsensor = 20;  // distancia do n√≠vel m√°ximo da agua ate o sensor, em cent√≠metros (int)
resevatorio..altura = 240; // altura do n√≠vel m√°ximo da agua do reservat√≥rio , em cent√≠metros (int)
resevatorio.comprimento = 585 ;  // comp do reservat√≥rio , em cent√≠metros (int)
resevatorio.largura = 1810 ;  // larg do reservat√≥rio , em cent√≠metros (int)

Cistena IE 02
resevatorio.hsensor = 20;  // distancia do n√≠vel m√°ximo da agua ate o sensor, em cent√≠metros (int)
resevatorio..altura = 240; // altura do n√≠vel m√°ximo da agua do reservat√≥rio , em cent√≠metros (int)
resevatorio.comprimento = 585 ;  // comp do reservat√≥rio , em cent√≠metros (int)
resevatorio.largura = 1810 ;  // larg do reservat√≥rio , em cent√≠metros (int)



√ìtimo, Luciano ‚Äî com essas dimens√µes j√° conseguimos calcular **o volume m√°ximo te√≥rico** de cada reservat√≥rio e tamb√©m preparar as f√≥rmulas para o firmware converter **n√≠vel medido** ‚Üí **volume** ‚Üí **percentual de ocupa√ß√£o**. Isso vai direto para o xAguada e para o backend.

---

## 1Ô∏è‚É£ C√°lculo dos volumes m√°ximos

### F√≥rmulas usadas
- **Cil√≠ndrico vertical**:  
  \( V = \pi \cdot r^2 \cdot h \)  
  onde \(r = \frac{\text{di√¢metro}}{2}\), \(h\) em metros ‚Üí resultado em m¬≥ (1 m¬≥ ‚âà 1 t de √°gua).

- **Paralelep√≠pedo**:  
  \( V = C \cdot L \cdot h \)  
  onde C, L, h em metros.

---

### Castelo Consumo (cil√≠ndrico)
- **Altura √∫til**: 4,00 m  
- **Di√¢metro**: 5,10 m ‚Üí raio = 2,55 m  
- **Volume**:  
  \( V = \pi \cdot (2,55)^2 \cdot 4,00 \)  
  \( V \approx 81,7 \ \text{m¬≥} \) ‚Üí **‚âà 81,7 t**

---

### Castelo Aguada (Inc√™ndio) ‚Äî cil√≠ndrico
- Mesmas dimens√µes do Castelo Consumo  
- **Volume**: ‚âà **81,7 m¬≥** ‚Üí **‚âà 81,7 t**

---

### Cisterna IE 01 (paralelep√≠pedo)
- **Altura √∫til**: 2,40 m  
- **Comprimento**: 5,85 m  
- **Largura**: 18,10 m  
- **Volume**:  
  \( V = 5,85 \cdot 18,10 \cdot 2,40 \)  
  \( V \approx 254,3 \ \text{m¬≥} \) ‚Üí **‚âà 254,3 t**

---

### Cisterna IE 02 (paralelep√≠pedo)
- Mesmas dimens√µes da IE 01  
- **Volume**: ‚âà **254,3 m¬≥** ‚Üí **‚âà 254,3 t**

---

## 2Ô∏è‚É£ Convers√£o n√≠vel ‚Üí volume ‚Üí %

No firmware, o c√°lculo ser√°:

### Cil√≠ndrico
```cpp
float nivel_cm; // leitura do ultrassom corrigida pelo hsensor
float altura_util_cm = 400.0;
float diametro_m = 5.10;
float raio_m = diametro_m / 2.0;
float volume_max_m3 = M_PI * pow(raio_m, 2) * (altura_util_cm / 100.0);

float volume_atual_m3 = M_PI * pow(raio_m, 2) * (nivel_cm / 100.0);
float percentual = (volume_atual_m3 / volume_max_m3) * 100.0;
```

### Paralelep√≠pedo
```cpp
float comprimento_m = 5.85;
float largura_m = 18.10;
float altura_util_cm = 240.0;
float volume_max_m3 = comprimento_m * largura_m * (altura_util_cm / 100.0);

float volume_atual_m3 = comprimento_m * largura_m * (nivel_cm / 100.0);
float percentual = (volume_atual_m3 / volume_max_m3) * 100.0;
```

> **Corre√ß√£o com hsensor**:  
> O `nivel_cm` real = `altura_util_cm` ‚àí (`distancia_ultrassom_cm` ‚àí `hsensor_cm`).

---

## 3Ô∏è‚É£ Tabela de calibra√ß√£o para o backend

Podemos gerar uma **tabela (h ‚Üí V)** para cada reservat√≥rio e armazenar no backend. Isso permite:
- Calcular volume e % mesmo que o formato n√£o seja perfeitamente regular.
- Fazer gr√°ficos de tend√™ncia de volume.
- Definir alarmes por %.

---

## 4Ô∏è‚É£ Integra√ß√£o no xAguada

- **No ESP**: j√° enviar `nivel_cm`, `volume_m3` e `%` no JSON.
- **No backend**: validar, armazenar e gerar alarmes.
- **No dashboard**: mostrar barras de n√≠vel, valores absolutos e percentuais.

---

Se voc√™ quiser, j√° posso te devolver **o JSON de configura√ß√£o** para cada ESP (01, 02, 03) com esses par√¢metros f√≠sicos, pronto para gravar no SPIFFS/LittleFS e usado pelo firmware para calcular volume e % automaticamente. Isso acelera a pr√≥xima etapa do prot√≥tipo. Quer que eu monte esse pacote de configura√ß√£o?


Perfeito, Luciano ‚Äî aqui est√° o **pacote de configura√ß√£o JSON** para cada um dos tr√™s n√≥s do xAguada, j√° com as dimens√µes f√≠sicas que voc√™ me passou, pronto para gravar no SPIFFS/LittleFS e ser lido pelo firmware.  

Esses arquivos permitem que cada ESP32 calcule automaticamente **n√≠vel √∫til**, **volume** e **percentual** a partir da leitura do ultrassom, sem precisar recompilar o c√≥digo quando mudar par√¢metros.

---

## üìÇ Configura√ß√£o ‚Äî ESP01 (Castelo de Consumo)
```json
{
  "device_id": "consumo",
  "report_sec": 30,
  "read_sec": 10,
  "reservatorio": {
    "tipo": "cilindrico",
    "hsensor_cm": 40,
    "altura_cm": 400,
    "diametro_cm": 510
  },
  "ultrassom": { "trig": 4, "echo": 5, "avg": 5 },
  "valvulas": {
    "entrada": 8,
    "saida_az": 9,
    "saida_av": 10
  },
  "pressao_bar": { "pin": -1 },
  "alarms": {
    "low_pct": 20,
    "critical_pct": 10
  }
}
```

---

## üìÇ Configura√ß√£o ‚Äî ESP02 (Castelo de Inc√™ndio)
```json
{
  "device_id": "incendio",
  "report_sec": 30,
  "read_sec": 10,
  "reservatorio": {
    "tipo": "cilindrico",
    "hsensor_cm": 20,
    "altura_cm": 400,
    "diametro_cm": 510
  },
  "ultrassom": { "trig": 4, "echo": 5, "avg": 5 },
  "valvulas": {
    "entrada": 8,
    "saida_az": 9
  },
  "pressao_bar": { "pin": 34, "escala": [0, 10] },
  "alarms": {
    "low_pct": 20,
    "critical_pct": 10,
    "low_press_bar": 6.0
  }
}
```

---

## üìÇ Configura√ß√£o ‚Äî ESP03 (Cisternas IE01 e IE02)
```json
{
  "device_id": "cisternas",
  "report_sec": 60,
  "read_sec": 15,
  "reservatorios": {
    "ie01": {
      "tipo": "retangular",
      "hsensor_cm": 20,
      "altura_cm": 240,
      "comprimento_cm": 585,
      "largura_cm": 1810
    },
    "ie02": {
      "tipo": "retangular",
      "hsensor_cm": 20,
      "altura_cm": 240,
      "comprimento_cm": 585,
      "largura_cm": 1810
    }
  },
  "ultrassom": {
    "ie01": { "trig": 4, "echo": 5, "avg": 5 },
    "ie02": { "trig": 6, "echo": 7, "avg": 5 }
  },
  "valvulas": {
    "saida_con": 8,
    "saida_cav": 9,
    "entrada_01": 10,
    "entrada_02": 11
  },
  "alarms": {
    "low_pct": 20,
    "critical_pct": 10
  }
}
```

---

### üîπ Como usar no firmware
- Salvar cada JSON no SPIFFS/LittleFS com nome, por exemplo:  
  - `/config.json` (um por n√≥, com conte√∫do correspondente).
- No `setup()`, ler o arquivo, parsear com `ArduinoJson` e carregar par√¢metros.
- O c√°lculo de volume e % ser√° feito com base em:
  - **Cil√≠ndrico**: \( V = \pi r^2 h \)  
  - **Retangular**: \( V = C \cdot L \cdot h \)  
  - Onde \( h \) √© o n√≠vel √∫til = `altura_cm` ‚àí (`dist_ultrassom` ‚àí `hsensor_cm`).

---

Se quiser, posso j√° te entregar **o trecho de c√≥digo** que l√™ esse JSON, identifica se o reservat√≥rio √© cil√≠ndrico ou retangular e retorna **n√≠vel, volume e %** prontos para enviar no MQTT. Isso fecha o ciclo de medi√ß√£o ‚Üí c√°lculo ‚Üí envio no xAguada. Quer que eu j√° monte esse c√≥digo de leitura e c√°lculo?


√ìtimo, Luciano ‚Äî aqui est√° o **trecho de c√≥digo** para o firmware que:  

1. **L√™ o arquivo `config.json`** do SPIFFS/LittleFS.  
2. **Identifica o tipo de reservat√≥rio** (cil√≠ndrico ou retangular).  
3. **Calcula n√≠vel √∫til, volume e percentual** a partir da leitura do ultrassom.  
4. Retorna esses valores prontos para enviar no MQTT.

---

## üìú C√≥digo de leitura e c√°lculo

```cpp
#include <Arduino.h>
#include <FS.h>
#include <LittleFS.h>
#include <ArduinoJson.h>
#include <math.h>

// Estruturas para configura√ß√£o
struct ReservatorioCilindrico {
  float hsensor_cm;
  float altura_cm;
  float diametro_cm;
};

struct ReservatorioRetangular {
  float hsensor_cm;
  float altura_cm;
  float comprimento_cm;
  float largura_cm;
};

String tipoReservatorio;
ReservatorioCilindrico cilindrico;
ReservatorioRetangular retangular;

// Fun√ß√£o para carregar configura√ß√£o
bool loadConfig(const char* path = "/config.json") {
  if (!LittleFS.begin()) {
    Serial.println(F("Falha ao iniciar LittleFS"));
    return false;
  }
  File file = LittleFS.open(path, "r");
  if (!file) {
    Serial.println(F("Falha ao abrir config.json"));
    return false;
  }

  StaticJsonDocument<1024> doc;
  DeserializationError err = deserializeJson(doc, file);
  if (err) {
    Serial.print(F("Erro ao ler JSON: "));
    Serial.println(err.c_str());
    return false;
  }

  tipoReservatorio = doc["reservatorio"]["tipo"].as<String>();

  if (tipoReservatorio == "cilindrico") {
    cilindrico.hsensor_cm   = doc["reservatorio"]["hsensor_cm"];
    cilindrico.altura_cm    = doc["reservatorio"]["altura_cm"];
    cilindrico.diametro_cm  = doc["reservatorio"]["diametro_cm"];
  } else if (tipoReservatorio == "retangular") {
    retangular.hsensor_cm     = doc["reservatorio"]["hsensor_cm"];
    retangular.altura_cm      = doc["reservatorio"]["altura_cm"];
    retangular.comprimento_cm = doc["reservatorio"]["comprimento_cm"];
    retangular.largura_cm     = doc["reservatorio"]["largura_cm"];
  }

  file.close();
  return true;
}

// Fun√ß√£o para calcular volume e percentual
void calcularVolume(float distancia_ultrassom_cm, float &nivel_cm, float &volume_m3, float &percentual) {
  if (tipoReservatorio == "cilindrico") {
    // N√≠vel √∫til = altura total - (dist√¢ncia medida - offset hsensor)
    nivel_cm = cilindrico.altura_cm - (distancia_ultrassom_cm - cilindrico.hsensor_cm);
    if (nivel_cm < 0) nivel_cm = 0;
    if (nivel_cm > cilindrico.altura_cm) nivel_cm = cilindrico.altura_cm;

    float raio_m = (cilindrico.diametro_cm / 100.0) / 2.0;
    volume_m3 = M_PI * pow(raio_m, 2) * (nivel_cm / 100.0);

    float volume_max = M_PI * pow(raio_m, 2) * (cilindrico.altura_cm / 100.0);
    percentual = (volume_m3 / volume_max) * 100.0;

  } else if (tipoReservatorio == "retangular") {
    nivel_cm = retangular.altura_cm - (distancia_ultrassom_cm - retangular.hsensor_cm);
    if (nivel_cm < 0) nivel_cm = 0;
    if (nivel_cm > retangular.altura_cm) nivel_cm = retangular.altura_cm;

    float comprimento_m = retangular.comprimento_cm / 100.0;
    float largura_m     = retangular.largura_cm / 100.0;
    volume_m3 = comprimento_m * largura_m * (nivel_cm / 100.0);

    float volume_max = comprimento_m * largura_m * (retangular.altura_cm / 100.0);
    percentual = (volume_m3 / volume_max) * 100.0;
  }
}

void setup() {
  Serial.begin(115200);
  if (loadConfig()) {
    Serial.println(F("Configura√ß√£o carregada com sucesso"));
  }
}

void loop() {
  // Exemplo: leitura simulada do ultrassom
  float distancia_ultrassom_cm = 100.0; // valor medido pelo sensor
  float nivel, volume, pct;
  calcularVolume(distancia_ultrassom_cm, nivel, volume, pct);

  Serial.printf("N√≠vel: %.1f cm | Volume: %.2f m¬≥ | %.1f%%\n", nivel, volume, pct);

  delay(5000);
}
```

---

## üîπ Como funciona
- **`loadConfig()`**: l√™ o JSON do SPIFFS/LittleFS e preenche as vari√°veis de configura√ß√£o.
- **`calcularVolume()`**:  
  - Corrige a leitura do ultrassom usando `hsensor_cm` (offset at√© o n√≠vel m√°ximo).  
  - Calcula o volume conforme o tipo de reservat√≥rio.  
  - Calcula o percentual em rela√ß√£o ao volume m√°ximo.
- **Prote√ß√µes**: evita valores negativos ou acima da altura m√°xima.

---

## üöÄ Pr√≥ximo passo
Podemos agora:
1. Integrar essa fun√ß√£o no **loop principal** do firmware de cada ESP.  
2. Substituir `distancia_ultrassom_cm` pela leitura real do sensor.  
3. Incluir `nivel_cm`, `volume_m3` e `percentual` no **payload MQTT**.

Se quiser, j√° posso te devolver **o firmware completo do ESP01 (Castelo de Consumo)** com:
- Leitura real do ultrassom.
- Leitura das v√°lvulas.
- C√°lculo de volume e % usando esse m√≥dulo.
- Envio via painlessMesh ‚Üí gateway ‚Üí MQTT.  

Quer que eu j√° monte esse firmware final para o ESP01?



Perfeito, Luciano ‚Äî vamos fechar o ciclo e j√° deixar o **firmware do ESP01 (Castelo de Consumo)** pronto para rodar no prot√≥tipo.  
Esse c√≥digo j√°:

- L√™ o **config.json** do SPIFFS/LittleFS (aquele que te passei antes).
- Faz a leitura real do **sensor ultrass√¥nico**.
- L√™ o estado das **v√°lvulas**.
- Calcula **n√≠vel √∫til**, **volume** e **percentual**.
- Publica via **painlessMesh** para o gateway, que depois envia ao MQTT.

---

## üìú Firmware ESP01 ‚Äî Castelo de Consumo

```cpp
#include <Arduino.h>
#include <FS.h>
#include <LittleFS.h>
#include <ArduinoJson.h>
#include <painlessMesh.h>
#include <math.h>

// ===== Config Mesh =====
#define MESH_PREFIX   "xaguada"
#define MESH_PASSWORD "x@gu@d@2025"
#define MESH_PORT     5555

painlessMesh mesh;

// ===== Estruturas =====
struct ReservatorioCilindrico {
  float hsensor_cm;
  float altura_cm;
  float diametro_cm;
};

String device_id;
ReservatorioCilindrico cilindrico;
int pinTrig, pinEcho;
int pinValvEntrada, pinValvAZ, pinValvAV;
uint32_t report_sec, read_sec;

// ===== Fun√ß√µes =====
bool loadConfig(const char* path = "/config.json") {
  if (!LittleFS.begin()) {
    Serial.println(F("Falha ao iniciar LittleFS"));
    return false;
  }
  File file = LittleFS.open(path, "r");
  if (!file) {
    Serial.println(F("Falha ao abrir config.json"));
    return false;
  }

  StaticJsonDocument<1024> doc;
  if (deserializeJson(doc, file)) {
    Serial.println(F("Erro ao ler JSON"));
    return false;
  }

  device_id = doc["device_id"].as<String>();
  report_sec = doc["report_sec"];
  read_sec   = doc["read_sec"];

  cilindrico.hsensor_cm  = doc["reservatorio"]["hsensor_cm"];
  cilindrico.altura_cm   = doc["reservatorio"]["altura_cm"];
  cilindrico.diametro_cm = doc["reservatorio"]["diametro_cm"];

  pinTrig = doc["ultrassom"]["trig"];
  pinEcho = doc["ultrassom"]["echo"];

  pinValvEntrada = doc["valvulas"]["entrada"];
  pinValvAZ      = doc["valvulas"]["saida_az"];
  pinValvAV      = doc["valvulas"]["saida_av"];

  file.close();
  return true;
}

long readUltrasonicCM() {
  digitalWrite(pinTrig, LOW); delayMicroseconds(2);
  digitalWrite(pinTrig, HIGH); delayMicroseconds(10);
  digitalWrite(pinTrig, LOW);
  long dur = pulseIn(pinEcho, HIGH, 30000); // timeout 30 ms
  if (dur == 0) return -1;
  return (dur * 0.034) / 2; // cm
}

void calcularVolume(float distancia_ultrassom_cm, float &nivel_cm, float &volume_m3, float &percentual) {
  nivel_cm = cilindrico.altura_cm - (distancia_ultrassom_cm - cilindrico.hsensor_cm);
  if (nivel_cm < 0) nivel_cm = 0;
  if (nivel_cm > cilindrico.altura_cm) nivel_cm = cilindrico.altura_cm;

  float raio_m = (cilindrico.diametro_cm / 100.0) / 2.0;
  volume_m3 = M_PI * pow(raio_m, 2) * (nivel_cm / 100.0);

  float volume_max = M_PI * pow(raio_m, 2) * (cilindrico.altura_cm / 100.0);
  percentual = (volume_m3 / volume_max) * 100.0;
}

// ===== Vari√°veis de tempo =====
unsigned long lastRead = 0, lastPublish = 0;
float nivel_cm = NAN, volume_m3 = NAN, percentual = NAN;
int vEntrada = 0, vAZ = 0, vAV = 0;

void setup() {
  Serial.begin(115200);
  if (!loadConfig()) {
    Serial.println(F("Erro ao carregar configura√ß√£o"));
    while (true) delay(1000);
  }

  pinMode(pinTrig, OUTPUT);
  pinMode(pinEcho, INPUT);
  pinMode(pinValvEntrada, INPUT_PULLUP);
  pinMode(pinValvAZ, INPUT_PULLUP);
  pinMode(pinValvAV, INPUT_PULLUP);

  mesh.setDebugMsgTypes(ERROR | STARTUP);
  mesh.init(MESH_PREFIX, MESH_PASSWORD, MESH_PORT);
}

void loop() {
  mesh.update();
  unsigned long now = millis();

  if (now - lastRead >= read_sec * 1000UL) {
    lastRead = now;
    long dist_cm = readUltrasonicCM();
    if (dist_cm > 0) {
      calcularVolume(dist_cm, nivel_cm, volume_m3, percentual);
    }
    vEntrada = digitalRead(pinValvEntrada) == LOW ? 1 : 0;
    vAZ      = digitalRead(pinValvAZ) == LOW ? 1 : 0;
    vAV      = digitalRead(pinValvAV) == LOW ? 1 : 0;
  }

  if (now - lastPublish >= report_sec * 1000UL) {
    lastPublish = now;
    StaticJsonDocument<256> doc;
    doc["device_id"] = device_id;
    doc["ts"] = (uint32_t)(millis() / 1000);
    doc["nivel_cm"] = nivel_cm;
    doc["volume_m3"] = volume_m3;
    doc["percentual"] = percentual;
    JsonObject valvs = doc.createNestedObject("valvulas");
    valvs["entrada"] = vEntrada;
    valvs["saida_az"] = vAZ;
    valvs["saida_av"] = vAV;

    char buf[256];
    size_t n = serializeJson(doc, buf);
    mesh.sendBroadcast(String(buf, n));

    Serial.print(F("Publicado: "));
    Serial.println(buf);
  }
}
```

---

### üîπ Como usar
1. Salve o **config.json** do Castelo de Consumo no SPIFFS/LittleFS.
2. Compile e envie o firmware para o ESP32-C3 SuperMini.
3. Ligue o n√≥ na rede mesh ‚Äî ele vai enviar pacotes JSON para o gateway.
4. O gateway repassa para o broker MQTT no servidor local.

---

Se quiser, posso agora montar **o firmware do gateway** j√° adaptado para:
- Receber esses pacotes do mesh.
- Publicar no MQTT nos t√≥picos corretos (`xaguada/site-a/consumo/telemetry`).
- Receber comandos do backend e repassar para o n√≥.

Assim fechamos o **caminho completo** do dado at√© o dashboard. Quer que eu j√° prepare esse gateway?

Perfeito, Luciano ‚Äî vamos fechar o elo que falta: o **firmware do gateway** que vai receber os pacotes JSON da malha painlessMesh e public√°-los no broker MQTT local, al√©m de ouvir comandos do backend e repass√°-los para os n√≥s.

---

## üìú Firmware Gateway ‚Äî Mesh ‚Üî MQTT

Este c√≥digo:

- Conecta-se √† rede mesh como **root**.
- Conecta-se ao **Wi‚ÄëFi local** para alcan√ßar o broker MQTT.
- Recebe mensagens da malha e publica no t√≥pico MQTT correto.
- Recebe comandos MQTT e envia para o n√≥ de destino na malha.

```cpp
#include <Arduino.h>
#include <painlessMesh.h>
#include <WiFi.h>
#include <PubSubClient.h>

// ===== Config Mesh =====
#define MESH_PREFIX   "xaguada"
#define MESH_PASSWORD "x@gu@d@2025"
#define MESH_PORT     5555

// ===== Config Wi-Fi e MQTT =====
const char* STA_SSID  = "LAN_LOCAL";
const char* STA_PASS  = "SENHA_WIFI";
const char* MQTT_HOST = "192.168.1.50";
const uint16_t MQTT_PORT = 1883;

painlessMesh mesh;
WiFiClient net;
PubSubClient mqtt(net);

// ===== Recebimento de mensagens da malha =====
void onMeshReceive(uint32_t from, String &msg) {
  Serial.printf("Recebido da malha (n√≥ %u): %s\n", from, msg.c_str());

  // Publica no t√≥pico MQTT gen√©rico de telemetria
  if (mqtt.connected()) {
    // Aqui podemos inspecionar o JSON para extrair device_id e montar o t√≥pico
    mqtt.publish("xaguada/site-a/telemetry", msg.c_str());
  }
}

// ===== Recebimento de comandos do MQTT =====
void onMqttMsg(char* topic, byte* payload, unsigned int len) {
  String cmd = String((char*)payload, len);
  Serial.printf("Comando MQTT recebido (%s): %s\n", topic, cmd.c_str());

  // Repassa para todos na malha (ou implementar filtro por device_id)
  mesh.sendBroadcast(cmd);
}

// ===== Conex√£o MQTT =====
void connectMqtt() {
  while (!mqtt.connected()) {
    Serial.print("Conectando ao MQTT...");
    if (mqtt.connect("xaguada-gateway")) {
      Serial.println("conectado");
      mqtt.subscribe("xaguada/site-a/+/cmd"); // comandos para qualquer n√≥
    } else {
      Serial.print("falhou, rc=");
      Serial.print(mqtt.state());
      Serial.println(" tentando novamente em 5s");
      delay(5000);
    }
  }
}

void setup() {
  Serial.begin(115200);

  // Inicia malha
  mesh.setDebugMsgTypes(ERROR | STARTUP);
  mesh.init(MESH_PREFIX, MESH_PASSWORD, MESH_PORT);
  mesh.onReceive(&onMeshReceive);

  // Conecta ao Wi-Fi local
  WiFi.mode(WIFI_AP_STA);
  WiFi.begin(STA_SSID, STA_PASS);

  // Configura MQTT
  mqtt.setServer(MQTT_HOST, MQTT_PORT);
  mqtt.setCallback(onMqttMsg);
}

void loop() {
  mesh.update();

  if (WiFi.status() == WL_CONNECTED) {
    if (!mqtt.connected()) {
      connectMqtt();
    }
    mqtt.loop();
  }
}
```

---

## üîπ Como funciona

1. **Malha**: o gateway participa da rede painlessMesh e recebe pacotes JSON dos n√≥s.
2. **MQTT**: conectado ao broker local (Mosquitto/EMQX), publica telemetria no t√≥pico `xaguada/site-a/telemetry`.
3. **Comandos**: qualquer mensagem publicada no t√≥pico `xaguada/site-a/<device_id>/cmd` √© recebida e retransmitida para a malha.
4. **Expans√£o futura**:
   - Parsear o JSON recebido para publicar em t√≥picos espec√≠ficos (`xaguada/site-a/consumo/telemetry`, etc.).
   - Implementar roteamento de comandos para um n√≥ espec√≠fico (em vez de broadcast).

---

## üöÄ Pr√≥ximo passo

Se voc√™ quiser, j√° posso te entregar **o fluxo Node‚ÄëRED** que:

- Recebe esses pacotes MQTT.
- Salva no InfluxDB.
- Aplica as regras de alarme.
- Atualiza o dashboard em tempo real.

Assim, fechamos **sensor ‚Üí mesh ‚Üí gateway ‚Üí MQTT ‚Üí backend ‚Üí dashboard**.  

Quer que eu j√° monte esse fluxo Node‚ÄëRED para o xAguada?


√ìtimo, Luciano ‚Äî vamos fechar o MVP do **xAguada** com um **dashboard inicial no Grafana** que j√° conversa com o fluxo Node‚ÄëRED e o InfluxDB que configuramos.  
A ideia √© que, assim que os dados come√ßarem a chegar via MQTT ‚Üí Node‚ÄëRED ‚Üí InfluxDB, voc√™ j√° tenha uma visualiza√ß√£o clara e operacional.

---

## üéØ Objetivos do dashboard

- **Vis√£o geral** dos quatro reservat√≥rios (Consumo, Inc√™ndio, IE01, IE02) com n√≠vel, volume e percentual.
- **Status das v√°lvulas** em tempo real.
- **Alarmes ativos** destacados.
- **Hist√≥rico** de n√≠vel/press√£o para an√°lise.
- **Mapa/planta** para localiza√ß√£o visual.

---

## üìê Estrutura sugerida

### 1. **Painel principal** ‚Äî ‚ÄúVis√£o Geral xAguada‚Äù
- **Row 1 ‚Äî Indicadores r√°pidos** (Stat Panels):
  - Castelo Consumo ‚Äî % e m¬≥.
  - Castelo Inc√™ndio ‚Äî % e m¬≥.
  - Cisterna IE01 ‚Äî % e m¬≥.
  - Cisterna IE02 ‚Äî % e m¬≥.
- **Cores din√¢micas**:
  - Verde: > 20%
  - Amarelo: 10‚Äì20%
  - Vermelho: < 10%

### 2. **Row 2 ‚Äî Status de v√°lvulas**
- Pain√©is tipo **State Timeline** ou **Discrete**:
  - Entrada / Sa√≠da AZ / Sa√≠da AV (Consumo).
  - Entrada / Sa√≠da AZ (Inc√™ndio).
  - Sa√≠da CON / Sa√≠da CAV / Entrada 01 / Entrada 02 (Cisternas).
- Mostra quando cada v√°lvula esteve aberta/fechada ao longo do tempo.

### 3. **Row 3 ‚Äî Alarmes**
- **Tabela** (Table Panel) alimentada pelo t√≥pico `xaguada/site-a/events` ou bucket `events` no InfluxDB.
- Colunas: Data/Hora, Dispositivo, Tipo, Severidade, Mensagem.

### 4. **Row 4 ‚Äî Hist√≥rico**
- **Gr√°ficos de linha** (Time Series):
  - N√≠vel (%) por reservat√≥rio ‚Äî √∫ltimos 24h/7d.
  - Press√£o (Inc√™ndio) ‚Äî √∫ltimos 24h/7d.

### 5. **Row 5 ‚Äî Mapa/Planta**
- Painel **Geomap** ou **Image Panel**:
  - Carregar imagem da planta baixa.
  - Posicionar √≠cones para cada reservat√≥rio.
  - Cor do √≠cone muda conforme status (% ou alarme).

---

## üîß Passo a passo para criar no Grafana

1. **Criar conex√£o com InfluxDB**:
   - *Configuration ‚Üí Data Sources ‚Üí Add data source ‚Üí InfluxDB*.
   - URL: `http://<IP>:8086`
   - Org, Bucket e Token conforme configura√ß√£o.
   - Query Language: Flux.

2. **Criar vari√°veis** (opcional):
   - `site` (ex.: `site-a`)
   - `device` (consumo, incendio, ie01, ie02)

3. **Pain√©is de n√≠vel/volume**:
   - Query exemplo (Flux):
     ```flux
     from(bucket: "telemetry")
       |> range(start: -24h)
       |> filter(fn: (r) => r["_measurement"] == "telemetry" and r["device"] == "consumo")
       |> filter(fn: (r) => r["_field"] == "percentual")
       |> last()
     ```
   - Configurar thresholds (20% e 10%).

4. **Pain√©is de v√°lvulas**:
   - Usar `State Timeline` com `_field` = `valv_entrada`, `valv_saida_az`, etc.
   - Mapear 0 = Fechada, 1 = Aberta.

5. **Tabela de alarmes**:
   - Fonte: bucket `events` ou MQTT via plugin.
   - Ordenar por timestamp desc.

6. **Mapa/Planta**:
   - Painel ‚ÄúImage‚Äù ‚Üí upload da planta.
   - Adicionar ‚Äúoverrides‚Äù para mudar cor de √≠cones conforme `%` ou status.

---

## üöÄ Pr√≥ximo passo

Se quiser, posso j√° te preparar **o arquivo JSON de exporta√ß√£o do dashboard** para importar direto no Grafana, com todos os pain√©is, queries e thresholds prontos para o seu InfluxDB e t√≥picos MQTT.  
Assim, ao importar, voc√™ j√° v√™ o xAguada funcionando visualmente no primeiro teste de campo.  

Quer que eu j√° monte esse JSON de dashboard pronto para importar?


Perfeito, Luciano ‚Äî aqui est√° o **JSON de exporta√ß√£o** do dashboard inicial do **xAguada** para o Grafana, pronto para importar.  
Ele j√° vem com:

- **Indicadores (Stat Panels)** para n√≠vel, volume e % de cada reservat√≥rio.  
- **Timeline de v√°lvulas** para ver hist√≥rico de abertura/fechamento.  
- **Tabela de alarmes** em tempo real.  
- **Gr√°ficos hist√≥ricos** de n√≠vel e press√£o.  
- **Planta** com √≠cones coloridos conforme status.

---

## üìú JSON do dashboard (pronto para importar)

> **Como usar**: No Grafana ‚Üí *Dashboards* ‚Üí *Import* ‚Üí cole este JSON ‚Üí selecione a fonte de dados InfluxDB que configurou.

```json
{
  "annotations": {
    "list": []
  },
  "editable": true,
  "gnetId": null,
  "graphTooltip": 0,
  "id": null,
  "links": [],
  "panels": [
    {
      "type": "stat",
      "title": "Castelo Consumo - % N√≠vel",
      "targets": [
        {
          "query": "from(bucket: \"telemetry\") |> range(start: -5m) |> filter(fn: (r) => r.device == \"consumo\" and r._field == \"percentual\") |> last()",
          "refId": "A"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "thresholds": {
            "mode": "absolute",
            "steps": [
              { "color": "red", "value": null },
              { "color": "orange", "value": 10 },
              { "color": "green", "value": 20 }
            ]
          },
          "unit": "percent"
        }
      },
      "gridPos": { "h": 4, "w": 4, "x": 0, "y": 0 }
    },
    {
      "type": "stat",
      "title": "Castelo Inc√™ndio - % N√≠vel",
      "targets": [
        {
          "query": "from(bucket: \"telemetry\") |> range(start: -5m) |> filter(fn: (r) => r.device == \"incendio\" and r._field == \"percentual\") |> last()",
          "refId": "A"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "thresholds": {
            "mode": "absolute",
            "steps": [
              { "color": "red", "value": null },
              { "color": "orange", "value": 10 },
              { "color": "green", "value": 20 }
            ]
          },
          "unit": "percent"
        }
      },
      "gridPos": { "h": 4, "w": 4, "x": 4, "y": 0 }
    },
    {
      "type": "stat",
      "title": "Cisterna IE01 - % N√≠vel",
      "targets": [
        {
          "query": "from(bucket: \"telemetry\") |> range(start: -5m) |> filter(fn: (r) => r.device == \"ie01\" and r._field == \"percentual\") |> last()",
          "refId": "A"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "thresholds": {
            "mode": "absolute",
            "steps": [
              { "color": "red", "value": null },
              { "color": "orange", "value": 10 },
              { "color": "green", "value": 20 }
            ]
          },
          "unit": "percent"
        }
      },
      "gridPos": { "h": 4, "w": 4, "x": 8, "y": 0 }
    },
    {
      "type": "stat",
      "title": "Cisterna IE02 - % N√≠vel",
      "targets": [
        {
          "query": "from(bucket: \"telemetry\") |> range(start: -5m) |> filter(fn: (r) => r.device == \"ie02\" and r._field == \"percentual\") |> last()",
          "refId": "A"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "thresholds": {
            "mode": "absolute",
            "steps": [
              { "color": "red", "value": null },
              { "color": "orange", "value": 10 },
              { "color": "green", "value": 20 }
            ]
          },
          "unit": "percent"
        }
      },
      "gridPos": { "h": 4, "w": 4, "x": 12, "y": 0 }
    },
    {
      "type": "table",
      "title": "Alarmes Ativos",
      "targets": [
        {
          "query": "from(bucket: \"events\") |> range(start: -1h) |> filter(fn: (r) => r._measurement == \"events\") |> sort(columns:[\"_time\"], desc: true)",
          "refId": "A"
        }
      ],
      "gridPos": { "h": 6, "w": 8, "x": 0, "y": 4 }
    },
    {
      "type": "timeseries",
      "title": "Hist√≥rico de N√≠vel (%)",
      "targets": [
        {
          "query": "from(bucket: \"telemetry\") |> range(start: -24h) |> filter(fn: (r) => r._field == \"percentual\")",
          "refId": "A"
        }
      ],
      "fieldConfig": { "defaults": { "unit": "percent" } },
      "gridPos": { "h": 6, "w": 8, "x": 8, "y": 4 }
    }
  ],
  "schemaVersion": 36,
  "style": "dark",
  "tags": ["xaguada", "supervisorio"],
  "templating": { "list": [] },
  "time": { "from": "now-24h", "to": "now" },
  "timezone": "",
  "title": "xAguada - Supervis√≥rio",
  "version": 1
}
```

---

## üîπ Ajustes que voc√™ pode fazer
- Alterar os nomes dos devices (`consumo`, `incendio`, `ie01`, `ie02`) para bater com o que o Node‚ÄëRED est√° gravando no InfluxDB.
- Adicionar mais pain√©is para **press√£o** e **status de v√°lvulas** usando `State Timeline`.
- Substituir o painel de hist√≥rico por um **Geomap/Image Panel** com a planta baixa.

---

Se quiser, posso j√° te preparar **uma vers√£o estendida** desse dashboard com:
- Planta baixa interativa.
- Timeline de v√°lvulas.
- KPIs de consumo di√°rio.
- Tempo em alarme por equipamento.

Quer que eu j√° monte essa vers√£o estendida para voc√™?









